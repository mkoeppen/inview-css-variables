(function () {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var InViewCssVariables = /*#__PURE__*/function () {
    function InViewCssVariables(options) {
      _classCallCheck(this, InViewCssVariables);

      // extend default options
      this.options = _objectSpread2({
        baseClass: 'm-inview-css',
        positionTrackClass: 'm-inview-css--track-scroll-position',
        aboveViewportVariable: '--percentage-above-viewport',
        belowViewportVariable: '--percentage-below-viewport',
        inViewportVariable: '--in-view'
      }, options); // init events

      this.initEvents(); // first calculate

      this.checkAllElements();
    }

    _createClass(InViewCssVariables, [{
      key: "initEvents",
      value: function initEvents() {
        var _this = this;

        // refresh calculation after scroll
        document.addEventListener('scroll', function (e) {
          _this.checkAllElements();
        }); // refresh calculation after resize

        window.addEventListener('resize', function (e) {
          _this.checkAllElements();
        }); // refresh calculation after resize

        document.addEventListener('inview-css-variables', function (e) {
          _this.checkAllElements();
        });
      }
    }, {
      key: "checkAllElements",
      value: function checkAllElements() {
        // get all elements for calculation
        var allElements = document.querySelectorAll(".".concat(this.options.baseClass)); // get scroll position

        var viewport = {
          topOffset: window.pageYOffset,
          bottomOffset: window.pageYOffset + window.innerHeight
        }; // calculate for all elements

        var _iterator = _createForOfIteratorHelper(allElements),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var element = _step.value;
            this.checkSingleElement(element, viewport);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "isVisible",
      value: function isVisible(element) {
        var clientRect = element.getBoundingClientRect();

        if (element.offsetWidth + element.offsetHeight + clientRect.height + clientRect.width === 0) {
          return false;
        }

        var elemCenter = {
          start: clientRect.top,
          center: clientRect.top + element.offsetHeight / 2,
          end: clientRect.top + element.offsetHeight
        };
        if (elemCenter.end < 0) return false;
        if (elemCenter.start > (document.documentElement.clientHeight || window.innerHeight)) return false; // start

        var pointContainer = document.elementFromPoint(clientRect.left, elemCenter.start);

        do {
          if (pointContainer === element) return true;
        } while (pointContainer && (pointContainer = pointContainer.parentNode)); // center


        pointContainer = document.elementFromPoint(clientRect.left + element.offsetWidth / 2, elemCenter.center);

        do {
          if (pointContainer === element) return true;
        } while (pointContainer && (pointContainer = pointContainer.parentNode)); // bottom


        pointContainer = document.elementFromPoint(clientRect.left + element.offsetWidth, elemCenter.end);

        do {
          if (pointContainer === element) return true;
        } while (pointContainer && (pointContainer = pointContainer.parentNode));

        return false;
      }
    }, {
      key: "checkSingleElement",
      value: function checkSingleElement(element, viewport) {
        // get element position
        var elementTop = this.getOffsetTop(element);
        var elementHeight = element.offsetHeight;
        var elementBottom = elementTop + elementHeight; // check if element was in view

        var wasInView = element.dataset.wasInView || false;
        var isInView = this.isVisible(element); // is currently visible

        element.dataset.isInView = isInView; // is or was visible

        element.dataset.wasInView = isInView || wasInView; // calculate percentage if needed

        if (element.classList.contains(this.options.positionTrackClass)) {
          var percentageBelowViewport = 1 - Math.min(1, Math.max(0, (viewport.bottomOffset - elementTop) / elementHeight));
          var percentageAboveViewport = 1 - Math.min(1, Math.max(0, (elementBottom - viewport.topOffset) / elementHeight));
          element.style.setProperty(this.options.aboveViewportVariable, percentageAboveViewport);
          element.style.setProperty(this.options.belowViewportVariable, percentageBelowViewport);
          element.style.setProperty(this.options.inViewportVariable, (1 - percentageBelowViewport + percentageAboveViewport) / 2);
        }
      }
    }, {
      key: "getOffsetTop",
      value: function getOffsetTop(element) {
        // calculate offset
        var fullOffset = 0;

        for (var el = element; el; el = el.offsetParent) {
          fullOffset += el.offsetTop;
        }

        return fullOffset;
      }
    }]);

    return InViewCssVariables;
  }();

  window.InViewCssVariables = InViewCssVariables;

}());
